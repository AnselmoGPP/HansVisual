Architecture:
	- Handler
	- Graphics engine
	- Layer
	- Controls
	- 
You save vertex in a certain format in a layer (handler > layer).
Data from layer is sent to graphics engine (layer > handler > graphics engine).
Controls are managed (controls > handler)


---------------------------------------------------------------------------
> por qué open_window tiene que estar en init_GLFW?
> Por qué no desaparece el mouse en FP camera?
> Correct copy constructors and copy assignment operators overloading
- Replace glm by Eigen
- Por qué el primer punto de modified_rainbow[256][3] no está en x=0?
- Check correcteness of mutexes. Check the std::mutex *mut members.
> Extract class for selection, GUI, window creation, shader...
> More camera modes (plane)
> Adaptative aspect ratio
> Permitir continuidad entre camera modes, scenarios... Cambiar estas cosas sin cerrar la ventana (close_scenario())
- Functions: model( scale(), rotate(), translate() ), view(), proyection()
- send_XXX divided in more functions
- resize_buffer_set() independiente de layersSet->size() (poner variable miembro en plotter class)
- Move layer class members to private
- Send lines by segments
- Select camera type
- Put selections in a ImGui window
- Don't stretch the image when changing window size
- Singleton
- Function for pitch, roll, yaw - Improve cubes rotation
-Allow add_layer to be called after opening a window (open_window) / add_layer whenever you want (lock_guard)
- Basic macros for configuring visualizer
-Axis and grid (create generator functions), center of the sphere (option of the visualizer)
-Crear un find_package() para no tener que linkar todas las librerías en el CMake
- cam.adjustments(window);
- Argumentos como float(*buff)[3], en lugar de float * (asi se asegura que los argumentos se meten en el formato correcto y los índices dentro de la función se simplifican)
-Use get_vertex_ptr o get_color_ptr instead of checking all the types in visualizerClass before taking a buffer.
- Take into account layers of type none when modifying any layer state
-Can checkboxes be checked just after entering load_buffers()? this way, all the loading process could be avoided
-Keep points selected after a new scan is drawn in that layer (send_pts())
-CMake version (update) (add_package) add_compile_options, add Unix/Win32 flags
-Mutex for 2 flows: add_layer and main loop
-Save selected points from buffer > Load pts from buffer to GPU > repeat
-mut_fill_data (mutex)
-mut (vec<mutex*>)
-send_point/lines/triangles/cubes -> Put objects_to_print in mutex
-lock_points(mut[points][layer]), check_selection > lock_points(mut[pts][i]) (for), load_points > lock_points(mut[pts][i])
-send_palette
-fill_data_window 
- In check_ray(), don't check already selected points
-Una vez fuera del main loop (tras clicar esc), no debe poder llamarse a una free function
-Only one free function call per loop (main loop)
-Reorder surfaces (box planes and planes) so transparencies look right
-Optimizar selección. En lugar de chequear todos los puntos por cada píxel, averigüar la posición de cada punto en la pantalla. - Improve selection (see sciencesoftcode notes)
-Make sure you destroy all the news
-Are multiple windows possible? (1763) - Try many visualizer windows
- OOP: Encapsulation, abstraction, inheritance, polymorphism
-http://csharphelper.com/blog/2015/12/build-a-geodesic-sphere-with-wpf-and-c/
- ImGui as static library
- Improve speed by passing directly arrays to OGL

- Allow relative paths for calling LoadShaders()
- Cubes complete rotation (rotation method for a point)
- Parameters window (toolbar) (camera, transparency, axis...)
- Shaper with loop and without it
- Ordenar buffer para cubos para perfecta transparencia
-> Optimizations... Vextex in cubes are written at least 3 times. Optimize this. Also circular points, point sizes, line thickness...
-> Selection (or small windows for showing info about objects)
-> Are mutexes covering every situation?


----- Future ---------------------------------------------------------

- Simplify the save_() and send_() functions internals (design patterns)
- Why the moving points get a different shape (deformation)?
- Caves
- Name generator
- IOs functions (point inside box, parser...)
- Market moves (gaussian bell?)
- Simular wave function
- 3D polynomial

----- Done ---------------------------------------------------------

- add_points, add_lines, add_triangles & add_cubes only callable once per layer per loop
- Create polyline()
- Clear layer
- find_layer("lines_1").send_points(...);
- Draw_grid Draw_axis
- add_layer() and delete_layer() during execution
